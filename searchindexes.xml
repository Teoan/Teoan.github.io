<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>MapStruct对象映射工具的使用</title><url>/post/mapstruct%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>技术</category></categories><tags><tag>MapStruct</tag></tags><content type="html"><![CDATA[官网地址 MapStruct官网 MapStruct官方文档 介绍 MapStruct是一个对象转换映射工具，用来不同类型责则对象间的转换，如DO、DTO、VO之间的互转，我们来看看官网的介绍。
MapStruct is a Java annotation processor for the generation of type-safe and performant mappers for Java bean classes. It saves you from writing mapping code by hand, which is a tedious and error-prone task. The generator comes with sensible defaults and many built-in type conversions, but it steps out of your way when it comes to configuring or implementing special behavior. 简单翻译一下：MapStruct 是一个 Java 注释处理器，用于为 Java bean 类生成类型安全和高性能的映射器。它使您免于手动编写映射代码，这是一项繁琐且容易出错的工作。生成器带有合理的默认值和许多内置的类型转换，但在配置或实现特殊行为时它可能会比较繁琐。
为什么要用MapStruct 对象间的字段转换映射，已经用许多现成可用的方案，用的比较多的应该是Spring中自带的BeanUtils，用起来也十分方便，但是美中不足的是其底层原理是使用了反射去实现字段间的映射，性能方面就很一般了。而MapStruct在这一点上，使用getter、setter实现，性能远远高于BeanUtils，以下是官网所描述的优点：
Fast execution by using plain method invocations instead of reflection Compile-time type safety. Only objects and attributes mapping to each other can be mapped, so there&rsquo;s no accidental mapping of an order entity into a customer DTO, etc. Self-contained code—no runtime dependencies Clear error reports at build time if: mappings are incomplete (not all target properties are mapped) mappings are incorrect (cannot find a proper mapping method or type conversion) Easily debuggable mapping code (or editable by hand—e.g. in case of a bug in the generator) 简单翻译一下： 通过使用普通方法调用而不是反射来实现快速执行 编译时类型安全。只能映射相互映射的对象和属性，因此不会出现将订单实体类意外映射到客户 DTO类 等。 自包含代码——无运行时依赖 如果出现以下情况，编译时可以被发现： 映射不完整（并非所有目标属性都已映射） 映射不正确（找不到合适的映射方法或类型转换） 易于调试的映射代码（或可手动编辑——例如，在生成器中出现错误的情况下） 使用 引入相关依赖 Maven ... &lt;properties&gt; &lt;org.mapstruct.version&gt;1.5.3.Final&lt;/org.mapstruct.version&gt; &lt;/properties&gt; ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ... &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ... Gradle plugins { ... id &#34;com.diffplug.eclipse.apt&#34; version &#34;3.26.0&#34; // Only for Eclipse } dependencies { ... implementation &#39;org.mapstruct:mapstruct:1.5.3.Final&#39; annotationProcessor &#39;org.mapstruct:mapstruct-processor:1.5.3.Final&#39; testAnnotationProcessor &#39;org.mapstruct:mapstruct-processor:1.5.3.Final&#39; // if you are using mapstruct in test code } ... MapStruct整合Lombok MapStruce和Lombok的实现原理类似，都是在编译期间对原有代码进行增强，生成对应代码，所以MapStruce和Lombok同时使用时，需注意一下pom文件的配置。 MapStruce官网关于Lombok的说明 可以参考以下pom配置文件：
&lt;properties&gt; &lt;maven.compiler.source&gt;13&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;13&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;org.mapstruct.version&gt;1.5.3.Final&lt;/org.mapstruct.version&gt; &lt;org.projectlombok.version&gt;1.18.24&lt;/org.projectlombok.version&gt; &lt;lombok-mapstruct-binding.version&gt;0.2.0&lt;/lombok-mapstruct-binding.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${org.projectlombok.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;13&lt;/source&gt; &lt;target&gt;13&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;${org.mapstruct.version}&lt;/version&gt; &lt;/path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${org.projectlombok.version}&lt;/version&gt; &lt;/path&gt; &lt;!--lombok版本大于1.18.16 需配置以下path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt; &lt;version&gt;${lombok-mapstruct-binding.version}&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 开始使用 创建需要映射的实体类 首先，我们创建一个用户实体类DO，和对应的DTO，字段先保持一致。
@Data @Builder public class UserDO { private String name; private Integer age; private String gender; private String phoneNumber; } @Data @Builder public class UserDTO { private String name; private Integer age; private String gender; private String phoneNumber; } 创建Mapper映射 创建一个接口，并使用MapStruct的@Mapper注解，MapStruct就可以生成对应的映射代码，实现对象间的映射转换。
创建通用泛型映射Mapper 我们可以将原实体类和目标实体类用泛型抽象出来，写一个通用的映射Mapper。
public interface BaseMapStruct&lt;SOURCE,TARGET&gt;{ TARGET toTarget(SOURCE source); SOURCE toSource(TARGET target); List&lt;SOURCE&gt; toSourceList(List&lt;TARGET&gt; targetList); List&lt;TARGET&gt; toTargetList(List&lt;SOURCE&gt; sourceList); } 创建具体的Mapper 有了通用的Mapper，具体类的Mapper只需要创建对应的接口并实现BaseMapStruct即可。
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING) //使用Spring容器托管类 public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { //特殊的字段转换处理 可以在具体的映射器上实现 } 测试基本映射 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Test public void testMapStruct(){ UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;).build(); log.info(userMapStruct.toTarget(userDO).toString()); } } 执行结果：
2023-01-14 22:26:06.265 INFO 8776 --- [ main] c.t.learning.MapStructApplicationTest : UserDTO(name=test, age=18, gender=man, phoneNumber=12345678) 查看MapStruct自动生成的映射实现类 MapStruct通过解析注解，在编译期间生成对应映射器的实现类，我们打开target文件夹中的对应路径，看一下自动生成的内容：
@Component public class UserMapStructImpl implements UserMapStruct { public UserMapStructImpl() { } public UserDTO toTarget(UserDO source) { if (source == null) { return null; } else { UserDTO.UserDTOBuilder userDTO = UserDTO.builder(); userDTO.name(source.getName()); userDTO.age(source.getAge()); userDTO.gender(source.getGender()); userDTO.phoneNumber(source.getPhoneNumber()); return userDTO.build(); } } public UserDO toSource(UserDTO target) { if (target == null) { return null; } else { UserDO.UserDOBuilder userDO = UserDO.builder(); userDO.name(target.getName()); userDO.age(target.getAge()); userDO.gender(target.getGender()); userDO.phoneNumber(target.getPhoneNumber()); return userDO.build(); } } public List&lt;UserDO&gt; toSourceList(List&lt;UserDTO&gt; targetList) { if (targetList == null) { return null; } else { List&lt;UserDO&gt; list = new ArrayList(targetList.size()); Iterator var3 = targetList.iterator(); while(var3.hasNext()) { UserDTO userDTO = (UserDTO)var3.next(); list.add(this.toSource(userDTO)); } return list; } } public List&lt;UserDTO&gt; toTargetList(List&lt;UserDO&gt; sourceList) { if (sourceList == null) { return null; } else { List&lt;UserDTO&gt; list = new ArrayList(sourceList.size()); Iterator var3 = sourceList.iterator(); while(var3.hasNext()) { UserDO userDO = (UserDO)var3.next(); list.add(this.toTarget(userDO)); } return list; } } } 由于使用类Spring容器托管，MapStruct自动生成了**@Component注解，将Bean注册到容器中，所以我们可以使用@Resoure**直接进行注入并使用。由于继承了泛型的Mapper，所以也生成了泛型Mapper中所定义的通用转换方法。值得注意的是，如果转换的对象使用了Lombok的Builder注解，MapStruct会使用对应的Builder去创建对象，反之则直接使用new的方式创建。
自定义字段间映射 字段名不同 在真实的业务场景中，往往会出现相互转换的实体间字段名称不一样的情况，MapStruct也提供了对应注解**@Mapping来解决这个问题。 比如，UserDO的字段phoneNumber对应的是UserDTO的phoneNum字段，我们可以使用@Mapping**将其映射。
@Data @Builder public class UserDO { private String name; private Integer age; private String gender; private String phoneNumber; } @Data @Builder public class UserDTO { private String name; private Integer age; private String gender; private String phoneNum; } @Mapper(componentModel = MappingConstants.ComponentModel.SPRING) public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { @Override @Mapping(source = &#34;phoneNumber&#34;,target = &#34;phoneNum&#34;) UserDTO toTarget(UserDO userDO); @Override @Mapping(source = &#34;phoneNum&#34;,target = &#34;phoneNumber&#34;) UserDO toSource(UserDTO userDTO); @Override @Mapping(source = &#34;phoneNum&#34;,target = &#34;phoneNumber&#34;) List&lt;UserDO&gt; toSourceList(List&lt;UserDTO&gt; userDTOS); @Override @Mapping(source = &#34;phoneNumber&#34;,target = &#34;phoneNum&#34;) List&lt;UserDTO&gt; toTargetList(List&lt;UserDO&gt; userDOS); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Test public void testMapStruct(){ UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;).build(); UserDTO userDTO = userMapStruct.toTarget(userDO); log.info(userDTO.toString()); log.info(userMapStruct.toSource(userDTO).toString()); } } 2023-01-15 21:47:41.370 INFO 65373 --- [ main] c.t.learning.MapStructApplicationTest : UserDTO(name=test, age=18, gender=man, phoneNum=12345678) 2023-01-15 21:47:41.371 INFO 65373 --- [ main] c.t.learning.MapStructApplicationTest : UserDO(name=test, age=18, gender=man, phoneNumber=12345678) 多个数据源 在某些场景下，一个DTO类的数据源往往不只来源于一个DO类。比如一个UserDTO类可能还要有其权限、用户组，头像等信息字段，这些字段的值不一定都来自于UserDO类，可能有对应的RuleDO类等。这种情况下，使用**@Mapping**注解也可以解决。 首先我们新建RuleDO类。
@Data @Builder public class RoleDO { /** * 名称 */ String name; /** * 编码 */ String code; } UserDTO新增roleName、roleCode字段。
@Data @Builder public class UserDTO { private String name; private Integer age; private String gender; private String phoneNum; private String roleName; private String roleCode; } 映射类中添加对应映射注解，值得注意的是，如果两个数据源类中都存在目标类中的字段，也需要使用**@Mapping**标记需要使用其中的哪一个。
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING) public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { @Override @Mapping(source = &#34;phoneNumber&#34;,target = &#34;phoneNum&#34;) UserDTO toTarget(UserDO userDO); @Override @Mapping(source = &#34;phoneNum&#34;,target = &#34;phoneNumber&#34;) UserDO toSource(UserDTO userDTO); @Override @Mapping(source = &#34;phoneNum&#34;,target = &#34;phoneNumber&#34;) List&lt;UserDO&gt; toSourceList(List&lt;UserDTO&gt; userDTOS); @Override @Mapping(source = &#34;phoneNumber&#34;,target = &#34;phoneNum&#34;) List&lt;UserDTO&gt; toTargetList(List&lt;UserDO&gt; userDOS); @Mappings(value = {@Mapping(source = &#34;userDO.phoneNumber&#34;,target = &#34;phoneNum&#34;), @Mapping(source = &#34;userDO.name&#34;,target = &#34;name&#34;), //由于UserDO和RoleDO中都存在name字段，所以需使用注解表明使用哪一个 @Mapping(source = &#34;roleDO.name&#34;,target = &#34;roleName&#34;), @Mapping(source = &#34;roleDO.code&#34;,target = &#34;roleCode&#34;) }) UserDTO toUserDTO(UserDO userDO, RoleDO roleDO); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Test public void testMapStruct(){ UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;).build(); RoleDO roleDO = RoleDO.builder().name(&#34;管理员&#34;).code(&#34;admin&#34;).build(); UserDTO userDTO = userMapStruct.toUserDTO(userDO,roleDO); log.info(userDTO.toString()); } } 2023-01-15 22:47:55.156 INFO 79977 --- [ main] c.t.learning.MapStructApplicationTest : UserDTO(name=test, age=18, gender=man, phoneNum=12345678, roleName=管理员, roleCode=admin) 子对象与子对象间的映射 子对象的映射 对象中如果存在子对象，那子对象中的字段也是可以平铺映射到一个类中的，也是使用**@Mapping**注解去指定映射。 比如现在userDO类中组合了RoleDO类。
@Data @Builder public class UserDO { private String name; private Integer age; private String gender; private String phoneNumber; private RoleDO roleDO; } 修改映射规则。
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING) public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { @Override @Mappings(value = {@Mapping(source = &#34;userDO.phoneNumber&#34;,target = &#34;phoneNum&#34;), @Mapping(source = &#34;userDO.name&#34;,target = &#34;name&#34;), @Mapping(source = &#34;userDO.roleDO.name&#34;,target = &#34;roleName&#34;), @Mapping(source = &#34;userDO.roleDO.code&#34;,target = &#34;roleCode&#34;) }) UserDTO toTarget(UserDO userDO); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Test public void testMapStruct(){ RoleDO roleDO = RoleDO.builder().name(&#34;管理员&#34;).code(&#34;admin&#34;).build(); UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;).roleDO(roleDO).build(); UserDTO userDTO = userMapStruct.toTarget(userDO); log.info(userDTO.toString()); } } 2023-01-16 22:00:39.916 INFO 52252 --- [ main] c.t.learning.MapStructApplicationTest : UserDTO(name=test, age=18, gender=man, phoneNum=12345678, roleName=管理员, roleCode=admin) 子对象的映射 如果源对象与目标对象中各自有对应的子对象，比如UserDO和UserDTO中各自有各自的RoleDO和RoleDTO类，这种情况也是可以成功进行映射转换的，，当然，也是通过配置**@Mapping**实现的。 首先创建对应的Role类。
@Data @Builder public class RoleDTO { /** * 名称 */ private String name; /** * 编码 */ private String code; } @Data @Builder public class RoleDO { /** * 名称 */ private String name; /** * 编码 */ private String code; } 然后创建子对象的映射器。
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING) public interface RoleMapStruct extends BaseMapStruct&lt;RoleDO, RoleDTO&gt;{ //可以在这里实现特殊处理 } 然后在User的映射器中**@Mapping**使用uses，将RoleMapStruct引入，User映射器中就可以使用引入的RoleMapStruct进行子对象的映射了。
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING, uses = RoleMapStruct.class) public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { @Override @Mapping(source = &#34;roleDO&#34;,target = &#34;roleDTO&#34;) //字段名不一致，手动指定 UserDTO toTarget(UserDO userDO); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Resource ObjectMapper objectMapper; @Test public void testMapStruct() throws JsonProcessingException { RoleDO roleDO = RoleDO.builder().name(&#34;管理员&#34;).code(&#34;admin&#34;).build(); UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;).roleDO(roleDO).build(); UserDTO userDTO = userMapStruct.toTarget(userDO); log.info(objectMapper.writeValueAsString(userDTO)); } } 2023-01-16 23:02:27.911 INFO 67249 --- [ main] c.t.learning.MapStructApplicationTest : {&#34;name&#34;:&#34;test&#34;,&#34;age&#34;:18,&#34;gender&#34;:&#34;man&#34;,&#34;phoneNumber&#34;:&#34;12345678&#34;,&#34;roleDTO&#34;:{&#34;name&#34;:&#34;管理员&#34;,&#34;code&#34;:&#34;admin&#34;}} 基本类型的隐式转换和字符串的格式化 有的时候，映射的两个类之间的字段类型并不会完全一致，如果对应字段为基本数据类型和他们的包装类型，则MapStruct会自动进行空值判断并映射赋值。值得注意的是，如果出现数据范围大的类型映射到数据范围较小的类型如从long到int，则会出现精度丢失的问题，我们可以在Mapper注解中设置处理策略，由于向下兼容，默认为ReportingPolicy.IGNORE。
@Data @Builder public class UserDO { private String name; private Integer age; private Integer height; private String gender; private String phoneNumber; private Date createDate; } @Data @Builder public class UserDTO implements Serializable { private String name; private int age; //基本类型间自动映射 private String gender; private String height; //数字字符串格式化 private String phoneNumber; private String createDate; //日期格式化 } @Mapper(componentModel = MappingConstants.ComponentModel.SPRING) public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { @Override @Mappings(value = { @Mapping(source = &#34;createDate&#34;,dateFormat = &#34;yyyy-MM-dd&#34;,target = &#34;createDate&#34;), @Mapping(source = &#34;height&#34;,numberFormat = &#34;#cm&#34;,target = &#34;height&#34;)}) UserDTO toTarget(UserDO userDO); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Resource ObjectMapper objectMapper; @Test public void testMapStruct() throws JsonProcessingException { UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;).createDate(new Date()).height(180).build(); UserDTO userDTO = userMapStruct.toTarget(userDO); log.info(objectMapper.writeValueAsString(userDTO)); } } 2023-01-20 22:03:17.990 INFO 99724 --- [ main] c.t.learning.MapStructApplicationTest : {&#34;name&#34;:&#34;test&#34;,&#34;age&#34;:18,&#34;gender&#34;:&#34;man&#34;,&#34;height&#34;:&#34;180cm&#34;,&#34;phoneNumber&#34;:&#34;12345678&#34;,&#34;createDate&#34;:&#34;2023-01-20&#34;} 自定义映射前和映射后的处理 MapStruct提供了两个注解，分别是AfterMapping，BeforeMapping用来处理映射前和映射后的自定义实现。以用户类为例，我们可以在映射前设置默认身高，在映射后判断是否为管理员。
@Data @Builder public class UserDO { private String name; private Integer age; private Integer height; private String roleName; private String gender; private String phoneNumber; private Date createDate; } @Data @Builder @AllArgsConstructor public class UserDTO implements Serializable { private String name; private int age; private String gender; private String height; private String phoneNumber; private String createDate; private Boolean admin; private String roleName; } 值得注意的是，如果使用AfterMapping，BeforeMapping，@Mapper注解需使用在抽象类中，当实体类使用Builder模式时，则@AfterMapping中需传入对应的Builder，或者是将@Mapper注解中的构造器声明关闭(builder = @Builder(disableBuilder = true))。 如下：
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING,builder = @Builder(disableBuilder = true)) //实体类使用构建器模式时，需关闭 public abstract class UserMapper { @BeforeMapping protected void setDefHeight(UserDO userDO){ if(ObjectUtils.isEmpty(userDO.getHeight())){ userDO.setHeight(170); } } @AfterMapping protected void setAdmin(@MappingTarget UserDTO userDTO){ userDTO.setAdmin(userDTO.getRoleName().equals(&#34;admin&#34;)); } public abstract UserDTO toTarget(UserDO userDO); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapper userMapper; @Resource ObjectMapper objectMapper; @Test public void testMapStruct() throws JsonProcessingException { UserDO userDO = UserDO.builder().name(&#34;test&#34;).age(18).phoneNumber(&#34;12345678&#34;).gender(&#34;man&#34;) .createDate(new Date()).roleName(&#34;admin&#34;).build(); UserDTO userDTO = userMapper.toTarget(userDO); log.info(objectMapper.writeValueAsString(userDTO)); } } 2023-01-25 13:13:06.347 INFO 6247 --- [ main] c.t.learning.MapStructApplicationTest : {&#34;name&#34;:&#34;test&#34;,&#34;age&#34;:18,&#34;gender&#34;:&#34;man&#34;,&#34;height&#34;:&#34;170&#34;,&#34;phoneNumber&#34;:&#34;12345678&#34;,&#34;createDate&#34;:&#34;2023/1/25 下午1:13&#34;,&#34;admin&#34;:true,&#34;roleName&#34;:&#34;admin&#34;} 将Map映射到Bean 在某些特殊的情况下，需要从Map中映射到特定的Bean中，MapStruct也提供了对应的支持，通过Mapping注解，同时可以自定义字段名映射规则。
@Mapper(componentModel = MappingConstants.ComponentModel.SPRING) public interface UserMapStruct extends BaseMapStruct&lt;UserDO, UserDTO&gt; { @Mapping(source = &#34;userName&#34;,target = &#34;name&#34;) //将map中userName为key的值映射到UserDO类中的name字段 UserDO toUserDO(Map&lt;String, String&gt; map); } 运行结果 @SpringBootTest @Slf4j public class MapStructApplicationTest { @Resource UserMapStruct userMapStruct; @Resource ObjectMapper objectMapper; @Test public void testMapToBean() throws JsonProcessingException { Map userMap = Map.of(&#34;userName&#34;,&#34;testName&#34;, &#34;height&#34;,&#34;2&#34;,&#34;roleName&#34;,&#34;admin&#34;); UserDO userDO = userMapStruct.toUserDO(userMap); log.info(objectMapper.writeValueAsString(userDO)); } } 2023-01-27 18:27:54.915 INFO 16729 --- [ main] c.t.learning.MapStructApplicationTest : {&#34;name&#34;:&#34;testName&#34;,&#34;age&#34;:null,&#34;height&#34;:2,&#34;roleName&#34;:&#34;admin&#34;,&#34;gender&#34;:null,&#34;phoneNumber&#34;:null,&#34;createDate&#34;:null} 简单分析下原理 善于仔细观察的同学应该已经发现了，使用了MapStruct后，在编译后的target目录中，会多出几个Mapper 的实现类。我们可以简单的看一下生成的Class。
@Component public class UserMapStructImpl implements UserMapStruct { public UserMapStructImpl() { } public UserDO toSource(UserDTO target) { if (target == null) { return null; } else { UserDO.UserDOBuilder userDO = UserDO.builder(); userDO.name(target.getName()); userDO.age(target.getAge()); if (target.getHeight() != null) { userDO.height(Integer.parseInt(target.getHeight())); } userDO.roleName(target.getRoleName()); userDO.gender(target.getGender()); userDO.phoneNumber(target.getPhoneNumber()); try { if (target.getCreateDate() != null) { userDO.createDate((new SimpleDateFormat()).parse(target.getCreateDate())); } } catch (ParseException var4) { throw new RuntimeException(var4); } return userDO.build(); } } public List&lt;UserDO&gt; toSourceList(List&lt;UserDTO&gt; targetList) { if (targetList == null) { return null; } else { List&lt;UserDO&gt; list = new ArrayList(targetList.size()); Iterator var3 = targetList.iterator(); while(var3.hasNext()) { UserDTO userDTO = (UserDTO)var3.next(); list.add(this.toSource(userDTO)); } return list; } } public List&lt;UserDTO&gt; toTargetList(List&lt;UserDO&gt; sourceList) { if (sourceList == null) { return null; } else { List&lt;UserDTO&gt; list = new ArrayList(sourceList.size()); Iterator var3 = sourceList.iterator(); while(var3.hasNext()) { UserDO userDO = (UserDO)var3.next(); list.add(this.toTarget(userDO)); } return list; } } public UserDTO toTarget(UserDO userDO) { if (userDO == null) { return null; } else { UserDTO.UserDTOBuilder userDTO = UserDTO.builder(); if (userDO.getCreateDate() != null) { userDTO.createDate((new SimpleDateFormat(&#34;yyyy-MM-dd&#34;)).format(userDO.getCreateDate())); } if (userDO.getHeight() != null) { userDTO.height((new DecimalFormat(&#34;#cm&#34;)).format(userDO.getHeight())); } userDTO.name(userDO.getName()); if (userDO.getAge() != null) { userDTO.age(userDO.getAge()); } userDTO.gender(userDO.getGender()); userDTO.phoneNumber(userDO.getPhoneNumber()); userDTO.roleName(userDO.getRoleName()); return userDTO.build(); } } public UserDO toUserDO(Map&lt;String, String&gt; map) { if (map == null) { return null; } else { UserDO.UserDOBuilder userDO = UserDO.builder(); if (map.containsKey(&#34;userName&#34;)) { userDO.name((String)map.get(&#34;userName&#34;)); } if (map.containsKey(&#34;age&#34;)) { userDO.age(Integer.parseInt((String)map.get(&#34;age&#34;))); } if (map.containsKey(&#34;height&#34;)) { userDO.height(Integer.parseInt((String)map.get(&#34;height&#34;))); } if (map.containsKey(&#34;roleName&#34;)) { userDO.roleName((String)map.get(&#34;roleName&#34;)); } if (map.containsKey(&#34;gender&#34;)) { userDO.gender((String)map.get(&#34;gender&#34;)); } if (map.containsKey(&#34;phoneNumber&#34;)) { userDO.phoneNumber((String)map.get(&#34;phoneNumber&#34;)); } try { if (map.containsKey(&#34;createDate&#34;)) { userDO.createDate((new SimpleDateFormat()).parse((String)map.get(&#34;createDate&#34;))); } } catch (ParseException var4) { throw new RuntimeException(var4); } return userDO.build(); } } } MapStruct通过扫描解析Mapper注解，在编译的过程中生成对应的实现类的代码，从而实现对象间复杂的映射。问题来了，MapStruct是怎么在编译过程中生成额外的代码？这个就涉及到JSR269所提供的一套API注解处理器(Annotation Processor Tool),简称APT。
注解处理器(Annotation Processor Tool) APT允许我们在编译期访问和处理注解元数据，修改或创建源文件或类文件，像反射一样访问类、字段、方法和注解等元素。它可以用于减少样板代码，实现代码生成器，检查代码规范等等。要实现一个注解处理器，我们需要继承AbstractProcessor类，重写process方法，并在META-INF/services目录下注册我们的注解处理器。Lombok就是一个利用JSR269规范实现的插件，它可以通过注解来自动生成getter，setter，toString等方法。
总结 和Lombok的原理一样，MapStruct通过注解处理器，在编译的过程中扫描注解，生成对应的对应映射代码，大大方便了对象间的相互映射操作，不仅提高了开发效率，而且与其他实现方式相比，它的转换性能也是比反射要高的。在频繁需要映射对象的场景下尤为明显。可以说是一个优秀的代码工具了。
]]></content></entry><entry><title>城市大楼咖啡厅,早起午餐说晚安</title><url>/post/%E5%9F%8E%E5%B8%82%E5%A4%A7%E6%A5%BC%E5%92%96%E5%95%A1%E5%8E%85%E6%97%A9%E8%B5%B7%E5%8D%88%E9%A4%90%E8%AF%B4%E6%99%9A%E5%AE%89/</url><categories><category>摄影</category></categories><tags><tag>扫街</tag><tag>街拍</tag></tags><content type="html">城市大楼咖啡厅，早起午餐说晚安 偶尔抽出时间，到街边，到路上走走，也许能够收获自己意想不到到东西。</content></entry><entry><title>Redission分布式工具的使用</title><url>/post/redission%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>技术</category></categories><tags><tag>redis</tag><tag>redission</tag></tags><content type="html"><![CDATA[前言 记得上一次使用Redis的时候，还是在自己做的毕业设计项目上，当时抱着学习的目的，简单地做了查询的缓存处理。当然，在现在看来，小项目的简单查询根本用不到Redis来作为缓存中间件。而在实际的工作中，Rediss的使用，一般都用来缓存一些加载或者查询比较费时的、实时性要求比较低的数据，以提高web应用接口响应速度，进而提升用户体验。最近了解到Redission分布式工具，于是便有了这篇文章，记录下自己的使用过程。
什么是Redisson 以下是 Redisson官方 的一段描述
Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离(Separation of Concern)，从而让使用者能够将精力更集中地放在处理业务逻辑上。
SpringBoot项目集成Redission分布式工具 集成Redission，一般集成SpringBoot项目模块，我都会在 maven官方仓库 搜索对应的依赖包。目前仓库上使用的最多的依赖包有两个。
依赖的选择 一个是Redisson原生依赖
&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.17.7&lt;/version&gt; &lt;/dependency&gt; 一个是SpringBoot官方提供的Starter包
&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.17.7&lt;/version&gt; &lt;/dependency&gt; 其实两个依赖包使用起来没多大区别，只是SpringBoot官方提供的Start包对spring应用有更好的支持。具体选择哪个，就看自己喜欢了。
版本的选择 Redisson的版本需要与SpringBoot的版本相对应，不然容易出现一些兼容性的问题。如果使用starter包引入的方式，我们可以参考 redisson-spring-boot-starter官方 给出的对应版本关系，选择对应的版本就好了。以下来自官方给出的版本对应关系。
redisson-spring-datamodule name Spring Bootversion redisson-spring-data-16 1.3.y redisson-spring-data-17 1.4.y redisson-spring-data-18 1.5.y redisson-spring-data-2x 2.x.y 查看自己引入的redisson-spring-boot-starter版本号是否与SpringBoot对应。 配置Redisson 配置Redisson可以有多种方式，如通过Config对象读取文件yaml文件等。而实际使用的最多的应该是集成在SpringBoot中，在分布式场景下，就可以统一在配置中心进行修改，根据不同环境的Redis部署方式，配置不同的Redisson配置。
使用通用的SpringBoot配置 spring: redis: database: host: port: password: ssl: timeout: cluster: nodes: sentinel: master: nodes: 使用Redisson独立的配置 集群模式 spring: redis: redisson: file: classpath:redisson.yaml #这里可以使用外部文件，也可以直接在config中配置 config: | clusterServersConfig: idleConnectionTimeout: 10000 connectTimeout: 10000 timeout: 3000 retryAttempts: 3 retryInterval: 1500 password: null subscriptionsPerConnection: 5 clientName: null loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; {} slaveSubscriptionConnectionMinimumIdleSize: 1 slaveSubscriptionConnectionPoolSize: 50 slaveConnectionMinimumIdleSize: 32 slaveConnectionPoolSize: 64 masterConnectionMinimumIdleSize: 32 masterConnectionPoolSize: 64 readMode: &#34;SLAVE&#34; nodeAddresses: - &#34;redis://127.0.0.1:7004&#34; - &#34;redis://127.0.0.1:7001&#34; - &#34;redis://127.0.0.1:7000&#34; scanInterval: 1000 threads: 0 nettyThreads: 0 codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; {} transportMode: &#34;NIO&#34; 单Redis节点模式 spring: redis: redisson: config: | singleServerConfig: idleConnectionTimeout: 10000 connectTimeout: 10000 timeout: 3000 retryAttempts: 3 retryInterval: 1500 password: null subscriptionsPerConnection: 5 clientName: null address: &#34;redis://127.0.0.1:6379&#34; subscriptionConnectionMinimumIdleSize: 1 subscriptionConnectionPoolSize: 50 connectionMinimumIdleSize: 32 connectionPoolSize: 64 database: 0 dnsMonitoringInterval: 5000 threads: 0 nettyThreads: 0 codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; {} transportMode: &#34;NIO&#34; 哨兵模式 spring: redis: redisson: config: | sentinelServersConfig: idleConnectionTimeout: 10000 connectTimeout: 10000 timeout: 3000 retryAttempts: 3 retryInterval: 1500 password: null subscriptionsPerConnection: 5 clientName: null loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; {} slaveSubscriptionConnectionMinimumIdleSize: 1 slaveSubscriptionConnectionPoolSize: 50 slaveConnectionMinimumIdleSize: 32 slaveConnectionPoolSize: 64 masterConnectionMinimumIdleSize: 32 masterConnectionPoolSize: 64 readMode: &#34;SLAVE&#34; sentinelAddresses: - &#34;redis://127.0.0.1:26379&#34; - &#34;redis://127.0.0.1:26389&#34; masterName: &#34;mymaster&#34; database: 0 threads: 0 nettyThreads: 0 codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; {} transportMode: &#34;NIO&#34; 主从模式 spring: redis: redisson: config: | masterSlaveServersConfig: idleConnectionTimeout: 10000 connectTimeout: 10000 timeout: 3000 retryAttempts: 3 retryInterval: 1500 failedAttempts: 3 password: null subscriptionsPerConnection: 5 clientName: null loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; {} slaveSubscriptionConnectionMinimumIdleSize: 1 slaveSubscriptionConnectionPoolSize: 50 slaveConnectionMinimumIdleSize: 32 slaveConnectionPoolSize: 64 masterConnectionMinimumIdleSize: 32 masterConnectionPoolSize: 64 readMode: &#34;SLAVE&#34; slaveAddresses: - &#34;redis://127.0.0.1:6381&#34; - &#34;redis://127.0.0.1:6380&#34; masterAddress: &#34;redis://127.0.0.1:6379&#34; database: 0 threads: 0 nettyThreads: 0 codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; {} transportMode: &#34;NIO&#34; 主流的配置就是上面的几种了, 各参数的含义可以参考具体的 官方说明 验证配置是否成功 编写测试类验证Redisson是否可用
@SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Test public void TestRedissonClient() throws IOException { RSet&lt;Object&gt; set = redissonClient.getSet(&#34;teoan&#34;); set.add(&#34;test&#34;); } } 查看Redis中的数据 可以看到redis中已经存在对应的Set集合数据,Redisson配置到这里就完了.
使用Redisson 分布式对象 Redisson提供的分布式对象有多个,如通用对象桶(Object Bucket)、二进制流(Binary Stream)、地理空间对象桶(Geospatial Bucket)、BitSet 原子整长形(AtomicLong)、原子双精度浮点(AtomicDouble)、话题(订阅分发)、布隆过滤器(Bloom Filter)等,每个Redisson对象实例都会有一个与之对应的Redis数据实例，可以通过调用getName方法来取得Redis数据实例的名称(key)。所有与Redis key相关的操作都归纳在RKeys这个接口,他们的使用方式具体可以 参考官方wiki ,其中我比较感兴趣的是这个话题对象,它可以实现类似于订阅分发的功能,和消息队列的思想差不多,我就以话题对象为例子,玩一下这个分布式对象。
话题(订阅分发) @SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Resource Executor execute; @Test public void TestRedissonClient() { RTopic topic = redissonClient.getTopic(&#34;Teoan&#34;); topic.addListener(String.class,(channel, message)-&gt;{ log.info(&#34;鸡汤来咯，看看鸡汤里面是什么[{}]&#34;,message); }); // 在其他线程或JVM节点 execute.execute(()-&gt;{ long clientsReceivedMessage = topic.publish(&#34;毒药&#34;); log.info(&#34;clientsReceivedMessage:{}&#34;,clientsReceivedMessage); }); } } 执行结果
. ____ _ __ _ _ /\\ / ___&#39;_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.5) 2022-11-13 11:43:16.388 INFO 12056 --- [ main] c.t.l.test.RedissonApplicationTest : Starting RedissonApplicationTest using Java 13.0.2 on Teoan-Desktop with PID 12056 (started by Teoan in F:\Linux\git_clone\TeoanStudy\Redisson) 2022-11-13 11:43:16.389 INFO 12056 --- [ main] c.t.l.test.RedissonApplicationTest : No active profile set, falling back to 1 default profile: &#34;default&#34; 2022-11-13 11:43:19.326 INFO 12056 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode 2022-11-13 11:43:19.329 INFO 12056 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Redis repositories in DEFAULT mode. 2022-11-13 11:43:19.461 INFO 12056 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 34 ms. Found 0 Redis repository interfaces. 2022-11-13 11:43:23.770 INFO 12056 --- [ main] org.redisson.Version : Redisson 3.18.0 2022-11-13 11:43:26.451 INFO 12056 --- [isson-netty-2-7] o.r.c.pool.MasterPubSubConnectionPool : 1 connections initialized for 127.0.0.1/127.0.0.1:6379 2022-11-13 11:43:26.559 INFO 12056 --- [isson-netty-2-3] o.r.c.pool.MasterConnectionPool : 32 connections initialized for 127.0.0.1/127.0.0.1:6379 2022-11-13 11:43:27.529 INFO 12056 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 1 endpoint(s) beneath base path &#39;/actuator&#39; 2022-11-13 11:43:27.600 INFO 12056 --- [ main] c.t.l.test.RedissonApplicationTest : Started RedissonApplicationTest in 12.609 seconds (JVM running for 18.62) 2022-11-13 11:43:28.821 INFO 12056 --- [ task-1] c.t.l.test.RedissonApplicationTest : clientsReceivedMessage:1 2022-11-13 11:43:28.822 INFO 12056 --- [ redisson-3-2] c.t.l.test.RedissonApplicationTest : 鸡汤来咯，看看鸡汤里面是什么[毒药] 进程已结束,退出代码0 限流器(RateLimiter) 简单讲一下限流器的用途，限流器用于限制总并发数，比如数据库连接池、线程池等。Redisson中的RateLimiter和Guava RateLimiter一样，也是使用令牌桶的限流算法，而不同的是，Redisson中的RateLimiter可以用来在分布式环境下现在请求方的调用频率。既适用于不同Redisson实例下的多线程限流，也适用于相同Redisson实例下的多线程限流。。算法逻辑大致为：令牌桶以固定的速率向桶中加入新的令牌，线程的请求会从桶里拿走一定数量的令牌，只要通中存在满足请求数量的令牌，请求就会被处理。比如我设置限流器一秒生成10个令牌，每个请求拿5个令牌，那么结果就是一秒最多处理2个请求。
@SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Resource Executor execute; @Test public void TestRedissonRateLimiter() { RRateLimiter rateLimiter = redissonClient.getRateLimiter(&#34;myRateLimiter&#34;); // 初始化 // 最大流速 = 每1秒钟产生10个令牌 rateLimiter.trySetRate(RateType.OVERALL, 10, 1, RateIntervalUnit.SECONDS); // 10个线程并发 for (int i = 0; i &lt; 10; i++) { execute.execute(()-&gt;{ RRateLimiter limiter = redissonClient.getRateLimiter(&#34;myRateLimiter&#34;); // 每次获取5个令牌 if(limiter.tryAcquire(5)){ log.info(&#34;get 5 tokens success&#34;); // ... }else { log.info(&#34;get 5 tokens fail&#34;); } }); } } } 2022-11-13 18:02:49.213 INFO 14872 --- [ task-1] c.t.l.test.RedissonApplicationTest : get 5 tokens success 2022-11-13 18:02:49.213 INFO 14872 --- [ task-3] c.t.l.test.RedissonApplicationTest : get 5 tokens success 2022-11-13 18:02:49.214 INFO 14872 --- [ task-2] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.215 INFO 14872 --- [ task-5] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.215 INFO 14872 --- [ task-6] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.216 INFO 14872 --- [ task-4] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.217 INFO 14872 --- [ task-3] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.219 INFO 14872 --- [ task-8] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.223 INFO 14872 --- [ task-7] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 2022-11-13 18:02:49.225 INFO 14872 --- [ task-1] c.t.l.test.RedissonApplicationTest : get 5 tokens fail 分布式集合 在Redisson提供的的集合类中，除了JDK中常见的Map，List，Set，还有一些在此基础上引申出来比较特殊集合对象，如映射缓存(RMapCache)、多值映射(RMultimap)、有序集(SortedSet)、计分排序集(ScoredSortedSet)等，除此之外，还有各种类型的队列对象，如双端队列(Deque)、阻塞队列(Blocking Queue)、有界阻塞队列(Bounded Blocking Queue)等。
映射缓存(RMapCache) RMapCache和RMap的区别在于多了一个元素淘汰功能，可以自定义Map中元素的有效时间 和 最长闲置时间 。
@SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Test public void TestRMapCache(){ RMapCache&lt;String, Object&gt; map = redissonClient.getMapCache(&#34;anyMap&#34;); // 有效时间 ttl = 10分钟 map.put(&#34;key1&#34;, 1, 10, TimeUnit.MINUTES); // 有效时间 ttl = 10分钟, 最长闲置时间 maxIdleTime = 10秒钟 map.put(&#34;key1&#34;, 2, 10, TimeUnit.MINUTES, 10, TimeUnit.SECONDS); // 有效时间 = 3 秒钟 map.putIfAbsent(&#34;key2&#34;, 3, 3, TimeUnit.SECONDS); // 有效时间 ttl = 40秒钟, 最长闲置时间 maxIdleTime = 10秒钟 map.putIfAbsent(&#34;key2&#34;, 4, 40, TimeUnit.SECONDS, 10, TimeUnit.SECONDS); } } 多值映射(RMultimap) 多值映射，基于Redisson的RMultimap对象允许Map中的一个字段值包含多个元素。
@SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Resource ObjectMapper objectMapper; @Test public void TestRMultimap() throws JsonProcessingException(){ RSetMultimap&lt;Object, Object&gt; myMultimap = redissonClient.getSetMultimap(&#34;myMultimap&#34;); myMultimap.put(&#34;key1&#34;,&#34;value1&#34;); myMultimap.put(&#34;key1&#34;,&#34;value2&#34;); myMultimap.put(&#34;key1&#34;,&#34;value3&#34;); myMultimap.put(&#34;key2&#34;,&#34;value1&#34;); myMultimap.put(&#34;key2&#34;,&#34;value2&#34;); Set&lt;String&gt; newValue1 = Set.of(&#34;newValue1&#34;, &#34;newValue2&#34;, &#34;newValue3&#34;); Set&lt;Object&gt; oldValues = myMultimap.replaceValues(&#34;key1&#34;, newValue1); log.info(&#34;oldValues:[{}]&#34;,objectMapper.writeValueAsString(oldValues)); Set&lt;Object&gt; removeValues = myMultimap.removeAll(&#34;key2&#34;); log.info(&#34;removeValues:[{}]&#34;,objectMapper.writeValueAsString(removeValues)); } } 2022-11-20 16:59:33.540 INFO 28632 --- [ main] c.t.l.test.RedissonApplicationTest : Started RedissonApplicationTest in 7.357 seconds (JVM running for 8.443) 2022-11-20 16:59:34.216 INFO 28632 --- [ main] c.t.l.test.RedissonApplicationTest : oldValues:[[&#34;value3&#34;,&#34;value2&#34;,&#34;value1&#34;]] 2022-11-20 16:59:34.220 INFO 28632 --- [ main] c.t.l.test.RedissonApplicationTest : removeValues:[[&#34;value2&#34;,&#34;value1&#34;]] 分布式锁 Redisson还提供了各种分布式锁，如可重入锁、公平锁、联锁、红锁等，这些锁对象也是完全符合Java的Lock规范，而且还提供异步（Async）、反射式（Reactive）和RxJava2标准的接口。
可重入锁 可重入锁，就是当前线程可以重复进入的锁，其他线程获取不到锁，则会阻塞。
@SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Resource ObjectMapper objectMapper; @Resource Executor execute; @Test public void TestRLock() throws InterruptedException { RLock lock = redissonClient.getLock(&#34;lock&#34;); //另外的线程拿锁 execute.execute(()-&gt;{ // 与主线程获取同一个锁 RLock rLock = redissonClient.getLock(&#34;lock&#34;); // 加锁以后10秒钟自动解锁 rLock.lock(10,TimeUnit.SECONDS); log.info(&#34;其他线程拿到锁啦&#34;); }); // 10秒内拿不到锁 会阻塞 lock.lock(5, TimeUnit.SECONDS); log.info(&#34;主线程拿到锁啦&#34;); lock.unlock(); } } 2022-12-20 21:48:09.200 INFO 2587 --- [ task-1] c.t.l.test.RedissonApplicationTest : 其他线程拿到锁啦 2022-12-20 21:48:19.190 INFO 2587 --- [ main] c.t.l.test.RedissonApplicationTest : 主线程拿到锁啦 信号量 基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。个人理解这个信号量有点像上文提到的限流器，执行 acquire 方法阻塞，直到有对应数量许可证可以获得然后拿走许可证，每个 release 方法增加若干个许可证。这个许可证和限流器的令牌，其实是很类似的。所以感觉也可以用信号量来实现限流器的功能。
@SpringBootTest @Slf4j public class RedissonApplicationTest { @Resource RedissonClient redissonClient; @Resource ObjectMapper objectMapper; @Resource Executor execute; @Test public void TestSemaphore() throws InterruptedException { // 一共设置量5个信号量 子线程先获取3个 execute.execute(()-&gt;{ try { // 需提前在redis中设置key为semaphore 值为对应信号量 RSemaphore semaphore = redissonClient.getSemaphore(&#34;semaphore&#34;); log.info(&#34;子线程可用的信号量：[{}]&#34;,semaphore.availablePermits()); semaphore.acquire(4); // 两秒后释放 Thread.sleep(2000); semaphore.release(4); } catch (InterruptedException e) { throw new RuntimeException(e); } }); Thread.sleep(1000); RSemaphore semaphore = redissonClient.getSemaphore(&#34;semaphore&#34;); log.info(&#34;主线程可用的信号量：[{}]&#34;,semaphore.availablePermits()); // 主线程获取不到对应数量的信号量 会阻塞 semaphore.acquire(3); log.info(&#34;主线程获取到对应数量信号量啦&#34;); semaphore.release(3); } } 2022-12-25 16:59:41.013 INFO 10324 --- [ task-1] c.t.l.test.RedissonApplicationTest : 子线程可用的信号量：[5] 2022-12-25 16:59:42.024 INFO 10324 --- [ main] c.t.l.test.RedissonApplicationTest : 主线程可用的信号量：[1] 2022-12-25 16:59:43.233 INFO 10324 --- [ main] c.t.l.test.RedissonApplicationTest : 主线程获取到对应数量信号量啦 总结 记录了下自己使用Redission的过程，如果你也正在入门使用Redission，那希望这篇文章对你有所帮助。文章内容大部分参考官方文档，官方文档yyds，嘻嘻。 通过自己手敲几个入门使用的案例，谈谈一下我的个人感受吧，Redis作为中间件应用的存在，也就说明它能够被多个服务应用所共用数据。而Redission正是利用了这一点，它将Java的集合数据结构Map、List、Set等用Redis对应的数据结构Hash、List、Set进行封装。在使用上，这些封装的集合对象和普通的Java集合对象并没有什么区别。在具体的存储实现上，一个是存在于JVM的内存中，另一个则是存到了Redis上对应的数据结构上。由于数据都存在于Redis中，那么对于多个实例的应用来说，这些数据是共用的，在高并发场景下，配合分布式锁，可以很大程度避免高并发场景下的一系列并发问题的发生。只要你了解Redis的基本数据结构，以及Java的基本集合对象，上手Redisson还是很快的。Redission提供了分布式相关的对象，以便于我们处理分布式场景下的相关复杂的业务问题，工具也只是手段，遇到具体的业务问题或场景，分析业务场景使用合适的分布式对象或者集合，或许可以让问题变得简单起来。
]]></content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html">折腾折腾后端，折腾折腾摄影，技术加摄影小白，嘻嘻。</content></entry><entry><title>关于Maven的多模块管理</title><url>/post/%E5%85%B3%E4%BA%8Emaven%E7%9A%84%E5%A4%9A%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/</url><categories><category>技术</category></categories><tags><tag>Maven</tag></tags><content type="html">Maven很强大，可以让我们在开发的过程中更加方便地去管理依赖。一般来说，如果是简单的个人项目的话，那项目分不分功能模块，就不显得那么重要。但是，如果项目有未来的发展甚至有更改架构或者多人协同开发的需求的话，那将项目各个功能拆分为多个功能模块就很有必要了。
将单模块项目拆分为多模块后有什么好处？ 单模块项目的的话，随着项目的发展和代码量的叠加，各个功能代码之间会不可避免地耦合在一起，这就与高内聚，低耦合背道而行了。将项目进行多模块拆分有以下好处：
降低耦合性：将项目拆分为各个模块，各个模块负责实现各自的功能，系统一旦出了问题，定位起来也比较方便。 使项目结构更加清晰：将项目按照职责或者功能进行拆分，使开发者更容易分析了解项目。 规范边界：不同的开发者可以根据不同的模块确定自己所负责的代码内容。 &amp;hellip; 如何按照职责或者功能进行拆分？ 按照职责拆分 所谓按照职责拆分，就是按照web系统各层的结构去拆分。
tclass-entity tclass-mapper tclass-service tclass-controller tclass-common tclass-util 按照功能拆分 按照功能拆分，将系统中各个功能拆分为各个独立的模块，不仅开发者分工清晰，还可以方便系统设计为微服务架构。
tclass-login 登录 tclass-notice 通知 tclass-work 作业 tclass-file 文件 tclass-user 用户 搭建多模块项目 创建父模块 首先，创建一个基本的Maven项目。因为作为父模块，依赖什么的都可以不用选。
我们看一下父模块中的pom.xml文件。
因为我们要将项目拆分为多个子模块，父模块中的内容就是各个子模块，所以我们将父模块中的src文件夹删除。
创建子模块 创建子模块和创建普通的项目一样，可以理解为在父项目中创建子项目。每一个子模块都有自己完整的项目目录结构，我们可以为子模块选择所需的依赖。
注意这里多了个父项的选择。
我们看一下子模块的目录结构，会发现它和普通Maven项目没有什么区别。
我们再看一下父模块的pom.xml，会发现多了和标签。
packaging为pom，表示选择最简单的打包方式，生成的构件只有它本身。而modules则表示子模块相对于当前模块的路径。我们再看一下子模块中的pom.xml文件中的内容。
parent标签表示该模块继承的父模块信息，包括artifactId、groupId、version等，其实这里还省略了relativePath标签，默认relativePath的值是**../pom.xml**，由于子模块在父模块的下级目录。所以这个标签一般是不用写的。倘若子模块与父模块的位置发生改变，那么这里就要对relativePath进行声明。
parent标签外的artifactId是子模块组件的id，由于声明了父模块，所以子模块中的groupId、version继承自父模块，可以不用填写。
子模块的依赖 若模块二依赖于模块一，则可以像引入Maven依赖一样，在模块二的pom.xml中，利用dependencies标签引入模块一。
需要注意的是，模块间的相互依赖，需要处理好各模块之间的依赖关系，否则容易导致循环依赖或者版本冲突。
关于依赖版本的控制 由于将项目拆分为多个子模块，子模块继承了父模块的一些信息。为了方便管理整个项目的依赖的版本，我们可以在父模块中对依赖版本进行声明，而子模块在声明依赖时，只需声明groupId、artifactId即可。
父模块
子模块
最后 以上内容其实是自己在做项目的过程中，对Maven多模块管理具体实现的记录。由于一些不可控降低原因，直到项目尾声后才想起来做一个笔记。Maven的强大远远不止于此，还有许多功能等着我去发现。</content></entry><entry><title>记录一下SpringSecurity的使用过程</title><url>/post/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bspringsecurity%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B/</url><categories><category>技术</category></categories><tags><tag>SpringSecurity</tag></tags><content type="html"><![CDATA[写在前面 在学习项目的过程中，发现权限认证管理使用的是SpringSecurity，SpringSecurity功能非常强大，由于之前没接触过，所以此写下自己的入门使用过程。
什么是SpringSecurity？ Spring Security是一套认证授权框架,支持认证模式如HTTP BASIC 认证头 (基于 IETF RFC-based 标准),HTTP Digest 认证头 ( IETF RFC-based 标准),Form-based authentication (用于简单的用户界面),OpenID 认证等,Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制.
如何在SpringBoot中使用SpringSecurity？ 引入依赖 在创建项目的时候引入依赖。 直接在pom.xml中引入依赖。 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 引入依赖后Spring Security默认保护所有接口。
配置Spring Security Spring Security提供了一个适配器，可以在适配器的实现类中去配置Spring Security，包括认证方式、登录成功失败后跳转的页面、API接口的拦截与放行等。
public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { } @Override public void configure(WebSecurity web) throws Exception { } @Override protected void configure(HttpSecurity http) throws Exception { } } WebSecurityConfigurerAdapter提供了三个configure函数需要我们去实现。
认证管理器配置方法 主要配置用户的认证、加密方式等。
protected void configure(AuthenticationManagerBuilder auth) throws Exception { //自定义的用户和角色数据提供者 auth.userDetailsService(customUserDetailsService).passwordEncoder(new PasswordEncoder() { //设置密码加密对象 //encode():把参数按照特定的解析规则进行解析 @Override public String encode(CharSequence charSequence) { // 使用Spring自带的加密工具加密字段 return DigestUtils.md5DigestAsHex(charSequence.toString().getBytes()); } // matches()验证从存储中获取的编码密码与编码后提交的原始密码是否匹配 // 第一个参数表示需要被解析的密码。第二个参数表示存储的密码。 @Override public boolean matches(CharSequence charSequence, String s) { return s.equals(DigestUtils.md5DigestAsHex(charSequence.toString().getBytes())); } }); } 由于项目中使用的用户名和密码是从数据库中获取的，所以我这里使用了一个自定义的用户和角色数据提供者customUserDetailsService。
public class CustomUserDetailsService implements UserDetailsService { @Autowired UserService userService; @Autowired RolesService rolesService; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user= userService.loadUserByUsername(s); if(user==null){ return new User(); } List&lt;Role&gt; roles = rolesService.getRoleByUid(user.getId()); user.setRoles(roles); return user; } } 自定义的用户和角色数据提供者需要实现UserDetailsService接口，这个接口很简单，只需要实现一个函数loadUserByUsername，这个函数需要我们自定义内容，实现通过用户名获取到一个UserDetails的实例对象。UserDetails也是一个接口，我用User对象去实现了UserDetails接口，所以我这里返回的是一个User对象。 下面是UserDetails的源码：
public interface UserDetails extends Serializable { //返回用户的权限集， 默认需要添加ROLE_ 前缀 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); //获取用户密码 String getPassword(); //获取用户名 String getUsername(); //账户是否不过期 boolean isAccountNonExpired(); //账户是否不锁定 boolean isAccountNonLocked(); //账户凭证是否不过期 boolean isCredentialsNonExpired(); //账户是否启用 boolean isEnabled(); } UserDetails接口需要我们实现7个函数。函数的作用我已经备注好了。
核心过滤器配置方法 一般用来设置忽略Spring Security 对静态资源的控制。
public void configure(WebSecurity web) throws Exception { //忽略对静态资源的控制 web.ignoring().antMatchers(&#34;/blogimg/**&#34;,&#34;/index.html&#34;,&#34;favicon.ico&#34;,&#34;/static/**&#34;); } 安全过滤器链配置方法。 这个方法比较重要也是使用最多的，HttpSecurity中需要我们配置很多东西，我们可以在HttpSecurity中自定义我们安全访问的规则。
protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&#34;/admin/category/all&#34;) .authenticated() .antMatchers(&#34;/admin/**&#34;,&#34;/reg&#34;) .hasRole(&#34;超级管理员&#34;)///admin/**和/reg的URL都需要有超级管理员角色，如果使用.hasAuthority()方法来配置，需要在参数中加上ROLE_,如下.hasAuthority(&#34;ROLE_超级管理员&#34;) .anyRequest() .authenticated()//其他的路径都是登录后即可访问 .and() .formLogin()//指定支持基于表单的身份验证。如果未指定FormLoginConfigurer#loginPage(String)，则将生成默认登录页面 .loginPage(&#34;/login_page&#34;)//设置登录页面 .failureUrl(&#34;/login_error&#34;)//设置登录失败后跳转的页面 .defaultSuccessUrl(&#34;/login_success&#34;,true)//设置登录成功后跳转的页面 .loginProcessingUrl(&#34;/login&#34;)//设置登录表单提交的页面 .usernameParameter(&#34;username&#34;)//设置表单提交用户名时使用的参数名 .passwordParameter(&#34;password&#34;)//设置表单提交密码时使用的参数名 .permitAll()//允许任何人访问 .and() .logout() .permitAll() .and() .csrf() .disable() .exceptionHandling() .accessDeniedHandler((httpServletRequest, httpServletResponse, e) -&gt; { httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN); httpServletResponse.setContentType(&#34;application/json;charset=utf-8&#34;); PrintWriter printWriter = httpServletResponse.getWriter(); printWriter.write(&#34;权限不足，请联系管理员&#34;);//返回失败json数据 printWriter.flush(); printWriter.close(); }); } 最后 SpringSecurity的基础使用就配置完了，可以根据项目需求，选择返回的是一个页面还是返回Json数据。SpringSecurity功能比较强大，貌似配置也比较麻烦一点？等有空我学了另一个安全管理框架&ndash;Shiro再来做个对比。
]]></content></entry><entry><title>关于spring-security 表单登录参数为null问题</title><url>/post/%E5%85%B3%E4%BA%8Espring-security-%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95%E5%8F%82%E6%95%B0%E4%B8%BAnul%E9%97%AE%E9%A2%98/</url><categories><category>技术</category></categories><tags><tag>axios</tag><tag>SpringSecurity</tag></tags><content type="html"><![CDATA[写在前面 由于第一次使用SpringSecurity做登录认证模块，在此期间遇到不少的问题，在此记录下自己遇到的坑。
前端使用了axios进行数据的交互，代码如下：
postRequest(&#39;/login&#39;, { username: username, password: password }).then(resp=&gt; { _this.loading = false; if (resp.status == 200) { //成功 } else { //失败 } }, resp=&gt; { //失败 }); postRequest函数内容如下：
export const postRequest = (url, params) =&gt; { return axios({ method: &#39;post&#39;, url: `${url}`, data: params, headers: { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded;charset=UTF-8&#39; } }) } 服务端登录配置如下：
protected void configure(HttpSecurity http) throws Exception { .... http.loginProcessingUrl(&#34;/login&#34;) .usernameParameter(&#34;username&#34;) .passwordParameter(&#34;password&#34;); .... } 服务端认证代码如下：
public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user= userService.loadUserByUsername(s); if(user==null){ return new User(); } List&lt;Role&gt; roles = rolesService.getRoleByUid(user.getId()); user.setRoles(roles); return user; } 前端进行登录请求的时候一直提示登录失败，查看服务端后台log如下： 根据log，查看了服务端代码，发现UserDetailsService接口中的loadUserByUsername接收到的字符串为null。所以返回了一个空的User对象，导致密码匹配认证不通过。所以登录失败了。
于是我使用了API调试工具进行登录测试： 发现可以登录成功，于是猜测可能是前端的交互方式有问题，于是Google了一下，发现SpringSecurity默认的登录数据是通过 key/value 的形式来传递的，默认情况下不支持 JSON格式的登录数据。 知道原因之后就好解决了，可以将axios中的参数改为key/value的方式：
postRequest(&#39;/login&#39;,&#39;username=&#39;+username+&#39;&amp;password=&#39;+password).then(resp=&gt;{ if(resp.status==200){ //成功 this.$alert(&#39;登录成功！&#39;,&#39;成功！&#39;); }else{ this.$alert(&#39;登录失败！&#39;,&#39;失败！&#39;); } },resp=&gt;{ _this.$alert(&#39;找不到服务器！&#39;, &#39;失败!&#39;); }) 或者使用qs库将Json对象以 k=v的格式进行格式化
export const postRequest = (url, params) =&gt; { return axios({ method: &#39;post&#39;, url: `${base}${url}`, data: qs.stringify(params), }) } 这样就可以成功登录，问题解决。
]]></content></entry><entry><title>关于vue-cli npm run build空白页问题</title><url>/post/%E5%85%B3%E4%BA%8Evue-cli-npm-run-build%E7%A9%BA%E7%99%BD%E9%A1%B5%E9%97%AE%E9%A2%98/</url><categories><category>技术</category></categories><tags><tag>Vue.js</tag><tag>SpringBoot</tag></tags><content type="html"><![CDATA[前言 今天准备调试自己写的SpringBoot后端api，打开之前部署在SpringBoot上的Vue.js前端页面时，发现是一整个空白的页面，由于自己刚接触SpringBoot和Vue.js前后端分离的开发模式，相关经验较少，在此记录自己的解决过程。
利用Chrome浏览器，按下f12打开控制台发现以下错误：文件路径错误 文件路径错误，导致css、js等文件获取不到，所以导致的页面的空白。
为什么会找不到文件呢？打开Vue项目下的dist目录，发现文件是存在的。
经过Goole查找相关资料和查阅Vue.config.js的官方配置参考后发现publicPath参数： 由于没有配置publicPath参数，所以默认的路径为绝对路径，导致引用资源文件时使用的也是绝对路径，所以也就渲染不了页面，最终显示为空白页。
在vue.config.js文件中将publicPath参数设置为相对路径，这样打出来的包可以被部署在任意路径了。
module.exports = { publicPath: &#34;./&#34;, assetsDir: &#34;./static&#34;, } 由于后端使用了Spring Security作权限管理，为了方便管理路径的权限，这里我还顺便配置了assetsDir参数，这参数是用来指定打包后的静态资源文件的位置的。 修改，保存后执行打包构建。
vue-cli-service build 打包完成后的目录： 打开index.html 页面正常地显示了。
参考： vue.config.js配置参考 ]]></content></entry><entry><title>利用Github上的Webhooks实现网站自动化部署</title><url>/post/%E5%88%A9%E7%94%A8github%E4%B8%8A%E7%9A%84webhooks%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url><categories><category>技术</category></categories><tags><tag>Git</tag><tag>Nginx</tag></tags><content type="html"><![CDATA[前言 由于本人的hexo博客是提交到GitHub上的，每一次更新博客都得在服务器上面手动pull更新，这样就显得十分蛋疼。所以Google了一下我的需求，发现了Github上的 Webhooks 功能，为此记录下我实现的过程。
安装依赖 由于Webhooks使用的是NodeJS，所以需要安装npm等相关的依赖。
sudo apt-get install nodejs sudo apt-get install npm 安装webhooks后端服务所需要的组件 安装github-webhook-handler
npm i -S github-webhook-handler 安装node进程管理工具pm2
npm i -g pm2 创建自动化部署脚本文件deploy.sh 在自定义目录下创建deploy脚本实现自动化部署，内容如下：
echo &#34;start deployment&#34; cd /home/xxx/xxx.github.io git fetch --all git reset --hard origin/master echo &#34;done&#34; 运行时如果会出现：
cd: can&#39;t cd to /home/xxx/xxx.github.io 原因可能是你的shell脚本在window上编写的，这样的话到linux系统运行时就会出现编码格式问题，window为dos而linux为unix。解决： 使用vim更改文件格式。
vim deploy.sh 查看文件格式：
:set ff 更改文件格式为unix：
:set ff=unix 或者 :set fileformat=unix 创建Webhook后端运行代码 在上文deploy.sh文件同一目录下创建webhook.js文件，内容如下
var http = require(&#39;http&#39;) var createHandler = require(&#39;github-webhook-handler&#39;) var handler = createHandler({ path: &#39;/auto_deploy&#39;, secret: &#39;xxxx&#39; }) // 上面的 secret 在配置Github上webhook时需要用到 function run_cmd(cmd, args, callback) { var spawn = require(&#39;child_process&#39;).spawn; var child = spawn(cmd, args); var resp = &#34;&#34;; child.stdout.on(&#39;data&#39;, function(buffer) { resp += buffer.toString(); }); child.stdout.on(&#39;end&#39;, function() { callback (resp) }); } http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end(&#39;no such location&#39;) }) }).listen(10000)//监听本地10000端口 handler.on(&#39;error&#39;, function (err) { console.error(&#39;Error:&#39;, err.message) }) handler.on(&#39;push&#39;, function (event) { console.log(&#39;Received a push event for %s to %s&#39;, event.payload.repository.name, event.payload.ref); run_cmd(&#39;sh&#39;, [&#39;./deploy.sh&#39;,event.payload.repository.name], function(text){ console.log(text) }); }) //deploy.sh为自动化部署的脚本文件 使用pm2进程管理器运行webhook.js pm2 start webhook.js 如果在运行的时候如果提示 github-webhook-handler is not defined 未找到 ，可以在目录中执行 npm link github-webhook-handler。 可以使用以下命令查看端口是否正常使用：
netstat -tlnp|grep 10000 正常结果如下图： 目前为止，一切顺利的话，webhook就在服务器上跑了起来，如果需要映射到公网的80端口，那么需要配置一下Nginx反向代理。
配置Nginx 配置Nginx使访问网站80端口的**/auto_deployURL转发到本地的10000端口，在/etc/nginx/nginx.conf**文件中加入如下配置：
server { # 80端口是http正常访问的接口 listen 80; server_name xxx.com; location /auto_deploy { proxy_pass http://127.0.0.1:10000; } } 重启Nginx：
sudo systemctl restart nginx.service 配置Github上的Webhook 进入Github项目地址，点击设置按钮，找到Webhooks，进行如下配置： 其中，Secret项需要和webhook.js文件中的保持一致，Content type 选择application/json。 不出意外的话可以看到最近提交是否成功。 ]]></content></entry><entry><title>关于ASP.NET中Ajax请求错误的问题</title><url>/post/%E5%85%B3%E4%BA%8Easp.net%E4%B8%ADajax%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/</url><categories><category>技术</category></categories><tags><tag>ASP.NET</tag><tag>Ajax</tag></tags><content type="html">记录下自己做作业时遇到的问题。
在ASP.NET中使用Jquery+Ajax请求时发生身份验证错误 错误如下图所示： 解决：找到APP_Start文件夹，更改RouteConfig.cs中AutoRedirectMode的配置。 原本为:
settings.AutoRedirectMode = RedirectMode.Permanent; 改为：
settings.AutoRedirectMode = RedirectMode.Off;</content></entry><entry><title>记录一下Java Web项目遇到的问题</title><url>/post/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bjava-web%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url><categories><category>技术</category></categories><tags><tag>Java Web</tag></tags><content type="html"><![CDATA[前言 最近对Java Web应用感兴趣，之前从来没接触过，所以写了篇博文记录自己遇到的问题和解决办法，便于自己回顾复习。
关于反射机制中的BeanUtils开发包 在利用BeanUtils开发包封装数据到Bean对象的过程中，特殊对象日期不能直接封装到Bean对象中，需要手动注册一个日期转换器对Date对象进行转换。
ConvertUtils.register(new DateLocaleConverter(), Date.class); 如果按照上面的代码，则会出现类似错误
org.apache.commons.beanutils.ConversionException: Error parsing date &#39;2019-10-10&#39; at position=4 原因是没有给转换器设置对应的地区区域日期格式。查看源码发现DateLocaleConverter类有构造函数DateLocaleConverter(Locale locale, String pattern)，最终解决方法：
DateLocaleConverter converter = new DateLocaleConverter(Locale.getDefault(),&#34;yyyy-MM-dd&#34;); converter.setLenient(true);//实现日期自动转换，如输入类似&#39;2019-14-30&#39;的日期时，会自动转换成&#39;2020-03-1&#39; ConvertUtils.register(converter, Date.class); 关于C3P0连接池的配置和使用 使用C3P0连接池链接数据库进行增删改查时出现警告：
com.mchange.v2.c3p0.cfg.C3P0Config.getUnspecifiedUserProperties named-config with name &#39;mysql&#39; does not exist. Using default-config. 并抛出异常：
java.sql.SQLException: No suitable driver 原因：c3p0 获取不到配置文件的内容，使用了默认配置，导致找不到对应的数据库链接。 解决办法：
检查xml配置文件中的driverClass和jdbcUr是否写错。 检查c3p0-config.xml是否正确存在于src目录下。 检查c3p0-config.xml第一行是否为空。 关于Mysql插入中文时数据库显示乱码 在使用c3p0连接池对中文数据进行插入时出现:
Caused by: java.sql.SQLException: Incorrect string value: &#39;\xF0\x9F\x98\x80\xE3\x80...&#39; for column &#39;show_content&#39; at row 1 Google 了一下，原因在于Mysql中的utf-8编码是按三个字节一个单位编码的，遇到以4个字节为单位的编码的数据就会出现切割，从而出现乱码。 按照网上给的解决方法：
将Mysql数据库的编码修改为utf8mb4 将数据表的编码修改为utf8mb4 修改c3p0连接池中Mysql连接配置代码 由于我使用的开发环境是idea+navicat，上述修改十分方便，然而还是不能解决我的问题。 我最后的解决办法：修改表中字段的字符集为utf8mb4。
关于jsp页面无法使用EL表达式 在使用String MVC开发过程中，使用Model类中的函数addAttribute向前端jsp页面传值时出现无法解析问题，抛出的异常如下：
java.lang.NumberFormatException: For input string: &#34;${begin }&#34; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:644) at java.base/java.lang.Integer.valueOf(Integer.java:989) at org.apache.jasper.compiler.JspUtil.coerceToInt(JspUtil.java:560) 抛出的异常显示对字符串**${begin }**的格式转换错误，于是找到该变量在jsp文件中的位置如下：
&lt;c:forEach begin=&#34;${begin }&#34; end=&#34;${end }&#34; var=&#34;i&#34;&gt; &lt;c:choose&gt; &lt;c:when test=&#34;${i eq pageInfo.pageNum }&#34;&gt; &lt;a class=&#34;page-numbers current&#34;&gt;${i}&lt;/a&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;a class=&#34;page-numbers&#34; href=&#34;${pageUrlPrefix}=${i}&#34;&gt;${i}&lt;/a&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:forEach&gt; 显然jsp页面无法将EL表达式中的**${begin }**解析为int。 原因如下：使用了老的JSP 1.2 声明，在JSP 1.2 声明中EL表达式默认是关闭的。 解决办法：使用新的JSP声明替换掉旧的声明。找到webapp/WEB-INF路径下的web.xml文件，将约束头替换成新的版本。 各版本约束头如下：
web-app 3.1 &lt;web-app xmlns=&#34;http://xmlns.jcp.org/xml/ns/javaee&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&#34; version=&#34;3.1&#34;&gt; jdk版本1.7以上 web-app 3.0 &lt;web-app xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&#34; version=&#34;3.0&#34;&gt; jdk版本1.6以上,支持jsp-config配置 web-app 2.5 &lt;web-app xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&#34; version=&#34;2.5&#34;&gt; jdk版本1.5以上 web-app 2.4 &lt;web-app xmlns=&#34;http://java.sun.com/xml/ns/j2ee&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&#34; version=&#34;2.4&#34;&gt; ]]></content></entry><entry><title>总结一下毕业设计项目中所遇到的问题</title><url>/post/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url><categories><category>技术</category></categories><tags><tag>ARM</tag></tags><content type="html"><![CDATA[前言 经历了两个多月的时间，终于把毕业设计的要求一步一步地慢慢实现了，中间踩过的坑数不胜数，由此列出了一些遇到的问题还有解决方法。 项目地址：https://github.com/Teoan/garage
在ubuntu中QtCreator无法输入中文 这个和输入法的类型有关，系统中所使用的输入法为Fcitx，然而Qt自带的插件中只支持iBus输入法。 解决：安装fcitx-libs-qt或fcitx-libs-qt5，在系统中找到libfcitxplatforminputcontextplugin.so这个动态库文件，复制到Qt安装目录中的**/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts**子目录下，重新运行程序即可解决。(注意:不同版本的Qt，插件的路径会有所不同)
arm-linux-gcc 成功在Qt编译，但是上传到板子上面运行出现： .-/bin/sh: ./xxxxx: not found
解决:我用的工具链版本是4.4.3，板子上内核是用5.4.0编译的，版本不匹配，换一个5.4.0的交叉编译工具链或者比5.4.0新就可以了。
关于交叉编译工具链的选择 网上查到的大多数ARM交叉编译工具链版本为4.4.3或者5.4.0，基本上4.4.3版本为32位系统的，5.4.0版本为64位的，然而现在网上资源默认你是用64位版本的系统，所以给的工具链都不会和你说是64位的，然而我用的是32位系统的，为此也遇到了许多坑。网上32位交叉编译工具链的资源比较少，要么得自己去编译，要么要一大堆积分去下载。偶然发现一家和ARM公司合作的 Linaro公司 ,虽然是英文的但是在里面可以找到各种版本个平台的交叉编译工具，再也不用为找ARM交叉编译工具链而烦恼了。 各平台各版本下载地址:https://releases.linaro.org/components/toolchain/binaries/
在ARM板上面使用opencv时，出现: error while loading shared libraries: /lib/libm.so.6: internal error
解决:出现这个问题应该是arm板上面的openvc库的软连接弄丢了，特别是在windows交叉编译的opencv的库,重新建立软连接就可以了。
关于误删除libc.so.6 删除后发现各种大多数指令都用不了，会出现没有找到动态库的情况。 解决:利用 LD_PRELOAD= 指定运行时的动态库，可以暂时使用常用命令重建软连接。例如：
LD_PRELOAD=/lib64/libc-2.12.so ln -s /lib64/libc-2.12.so /lib64/libc.so.6
使用easypr后识别结果为乱码 &ldquo;\u00E8\u0093\u009D\u00E7\u0089\u008C:\u00E5\u00B7\u009DA88888&rdquo;
解决: 原本的字符串处理方式为:
CPlate cp =plateVec.at(0); String ret = cp.getPlateStr(); QString str =QString::fromLocal8Bit(ret.c_str()); ui-&gt;label-&gt;setText(str); 改为:
CPlate cp =plateVec.at(0); cv::String ret = cp.getPlateStr(); ui-&gt;label-&gt;setText(ret.c_str()); 注意:ret.c_str()实现可以从cv::String类转换为count char * ,以上做法可以实现在Qt中显示中文，但是如果输出到终端还是会有乱码问题，如果需要终端输出，用cout直接输出String就可以了。
]]></content></entry><entry><title>关于Android客户端RSA加解密后出现乱码的问题</title><url>/post/%E5%85%B3%E4%BA%8Eandroid%E5%AE%A2%E6%88%B7%E7%AB%AFrsa%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%90%8E%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</url><categories><category>技术</category></categories><tags><tag>RSA</tag></tags><content type="html"><![CDATA[前言 在项目过程中需要通过okhttp获取服务器上数据库的数据后进行RSA解密。
解密可以成功，但是前面会出现����乱码
��������������������{&ldquo;status&rdquo;:0,&ldquo;userName&rdquo;:&ldquo;Teoan&rdquo;}
本以为是编码问题，但是转换成UTF-8后发现还是一样。
解决办法 查找的一番资料后完美解决，在Android移动端获取解密的Cipher类时要使用Cipher.getInstance(“RSA/ECB/PKCS1Padding”); 而在服务器端应该使用Cipher.getInstance(“RSA”);来获取。
本文参考文档( https://blog.csdn.net/totcw/article/details/72820444 )
]]></content></entry><entry><title>推荐一个特别好用的shell--zsh</title><url>/post/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E7%89%B9%E5%88%AB%E5%A5%BD%E7%94%A8%E7%9A%84shell-zsh/</url><categories><category>技术</category></categories><tags><tag>shell</tag><tag>zsh</tag></tags><content type="html"><![CDATA[介绍 Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。
特性有 可帮助用户键入常用命令选项及参数的可编程命令行补全功能，自带对数百条命令的支持 可与任意Shell共享命令历史 可在无需运行外部程序（如find）的情况下通过 文件扩展匹配文件 改进变量/数组处理方式 拼写检查 兼容多种模式(如bash等) 等等 Oh My Zsh介绍 用户社区网站&quot;Oh My Zsh&quot;收集Z shell的第三方插件及主题。截止于2018年，其GitHub源共有超过1000位贡献者、200多款插件和超过140款主题。同时也带有更新已安装插件及主题的自动更新工具。
zsh的安装 查看一下系统中已安装的shell
$ cat /etc/shells
如果没安装zsh，则需安装(以Ubuntu为例子，其他系统可自行谷歌或百度)
$ sudo apt-get install zsh
查看当前使用中的shell,并切换默认shell为zsh
$ echo $shell $ chsh -s /bin/zsh
注销出现登录就可以生效了。
Oh My Zsh的安装和使用 Oh My Zsh项目地址 安装Oh My Zsh之前，应该确保是否以安装zsh，不然回出现以下提示：
Zsh is not installed! Please install zsh first!
安装Oh My Zsh
wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
执行上面的命令后，Oh My Zsh就已经安装再你的系统中了，接下来可以对它进行主题配置。 Oh My Zsh的主题存在于 ~/。oh-my-zsh/thems 中，可以查看Oh My Zsh自带的的多种主题文件。
配置Oh My Zsh Oh My Zsh的默认配置文件路径为~/.zshrc，可以编辑文件内容修改zsh主题
vim ~/.zshrc
将11行的ZSH_THEME字段的值更改为自己喜欢的主题名称，如：
ZSH_THEME=&ldquo;ys&rdquo;
效果如下 配置完Oh My Zsh了，不过现在的zsh还不是那么的好用，它的强大在于它有许多非常方便人性化的插件，选择性地安装并使用，会让你的工作事半功倍。
Oh My Zsh插件推荐 Oh My Zsh的插件非常之多，一些是Oh My Zsh自带的插件，默认情况下没有开启，修改上文提到的.zshrc文件，可以选择性地启用自带插件。 例如开启web-search插件
plugins=(git web-search)
last-working-dir 顾名思义，last-working-dir插件可以保存你上一次退出命令行时的路径，当你再次进入命令行的时候自动切换到离开时的路径。这个插件特别好用，特别是工作在十分冗长的目录时，就不用记住路径了。
catimg 可以将路径中的图片用命令行打印到终端。这个我个人用得很少，当图片预览也是挺好玩的。
$ catimg xxxx.png
urltools urltools插件提供URL编码机制，可以使用urlencode进行URL编码
$ urlencode https://teoan.top/ https%3A%2F%2Fteoan.top%2F
urldecode 则是用来解码
$ urldecode https%3A%2F%2Fteoan.top%2F https://teoan.top/ z 这个插件用于快速的跳转访问过的路径，例如当你cd到 .oh-my-zsh/并离开此目录时，可以使用** z .oh-my-zsh/命令进行跳转，而且支持模糊跳转，也就是使用 z .oh-my**跳转也是可以的。
zsh-syntax-highlighting 项目地址 这个插件也是非常好用的，当你命令输入正确的时候会变命令绿色，反之会变红色，便于一眼看出错误。 安装
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
然后在.zshrc中加入相应插件名称
plugins=(其他的插件 zsh-syntax-highlighting)
利用source命令使之生效
source ~/.zshrc
zsh-autosuggestions 项目地址 这个插件可以实现命令自动补全功能，它会显示推荐的命令，然后可以按 → 补全，可以提高效率。 安装
git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
然后在.zshrc中加入相应插件名称
plugins=(其他的插件 zsh-autosuggestions)
git-open 项目地址 这个插件可以在终端远程打开当前项目的地址，当你改完本地代码后查看远程仓库会非常的方便。 安装
git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open
然后在.zshrc中加入相应插件名称
plugins=(其他的插件 git-open)
关于zsh的好用插件还有很多，插件装多了zsh容易变卡顿，所以建议还是按需安装。 想了解更多的插件可以参考：( https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins )
本文参考：（https://juejin.im/entry/5ae00e54f265da0b8635ea5c）
]]></content></entry><entry><title>Markdown常用语法归纳</title><url>/post/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%BD%92%E7%BA%B3/</url><categories><category>技术</category></categories><tags><tag>Markdown</tag></tags><content type="html"><![CDATA[前言 Markdown语法是一种越来越多人使用的轻量级标记语言，能够让写作的人不用过于关注样式，所以受到了越来越多的人的喜欢，下面是我的一些语法归纳。
标题 很多文章的回用到标题,在Markdowm的语法中，只需要在文本前加上**#就可以创建一级标题(记得#后面要加空格哦！)，同样的，二级标题就加上##**，以此类推，Markdown语法一共支持六级标题。效果如下：
# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 引用 在Markdown语法中使用引用只需要在整个段落前加上**&gt;**,比如：
&gt;这是一个引用 这是一个引用
区块的引用是可以嵌套的比如：
&gt;这个是一级引用 &gt;&gt;这个是二级引用 &gt;&gt;&gt;这个是三级引用 这个是一级引用
这个是二级引用
这个是三级引用
引用块里面也是可以使用其他markdown语法的，比如标题、列表、代码区块等。 拿上面的标题来举例子：
&gt;# 标题 标题 列表 列表也是写文章最常用的，markdown中有有序、无序还有代办列表。
无序列表 无序列表可以用星号(*)，加号(+)或者减号(-)作为列表标记。比如：
*AAA +BBB -CCC 效果如下：
AAA BBB CCC 有序列表 有序列表在数字后面加上英文的句号，如：
1. 2. 3. 效果如下： 1. 2. 3.
假如需要在列表项目里面加入引用，那么**&gt;**需要缩进：
这个是引用
这个也是引用
待办列表 这列表是带有可选框的。表示是否被勾选：
- [x] 想女朋友 - [x] 不惹女朋友生气 - [ ] 不爱女朋友 想女朋友 惹女朋友生气 不爱女朋友 代码 在markdown中代码块是使用```将其包裹在其中的， 在围栏式代码块中，你可以在```后面指定指定语言标识，比如```java，这样代码就有高亮了：
System.out.printf(&#34;hello world!&#34;); 强调 在markdown中，可以在文本前面使用 * 和 _ 来表示斜体和加粗，加上一对是斜体，两对是加粗。
\*斜体\* \_斜体\_ \_\_加粗\_\_ \*\*加粗\*\* 斜体 斜体 加粗 加粗
链接 markdown中链接用法是这样用的 你想要显示的文字 ，比如：
[Teoan的博客](https://teoan.github.io/) Teoan的博客 表格 在markdown中使用表格的语法其实很简单：
First | Second | Third ------- | ---------- | --------- First | Second | Third First | Second | Third First | Second | Third First Second Third First Second Third First Second Third First Second Third 还可以然表格中间居中(第二行冒号在哪边就向哪边对齐)：
First | Second | Third :------- | :----------: | ---------:	First | Second | Third First | Second | Third First | Second | Third First Second Third First Second Third First Second Third First Second Third 分割线 markdown中的分割线是用**&mdash;**来实现的：
分割线之上 --- 分割线之下 分割线之上
分割线之下
图片 markdown中插入图片的用法和链接差不多，![自定义文字](图片链接)，图片链接可以是本地图片的路径或者是网络链接:
![头像](https://i.imgur.com/JVemOFZ.jpg) 关于markdown常用的语法也就这些了，markdown还有很多好学又好用的功能，如果需要深入地了解markdown语法，可以参阅 Markdowm 中文文档 。
本文参考文档：( https://coding.net/help/doc/project/markdown.html#i-3 )
]]></content></entry><entry><title>用GitHub Page+Hexo搭建个人博客</title><url>/post/%E7%94%A8github-page+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/</url><categories><category>技术</category></categories><tags><tag>hexo</tag></tags><content type="html">前言 由于暑假在家极其容易咸鱼，对此在网上找了一些可以既可以花费时间去折腾又可以学到知识的东西，于是在知乎找到了这么一篇文章 GitHub+Hexo搭建个人网站详细教程 ,于是我花了一天的时间搭了一个属于自己的博客，用来记录一些琐碎的知识，还有自己在实践中遇到的一些坑，下面我会分享一下我搭个人博客所用到的资源和心得。
使用hexo搭博客遇到的问题 关于域名 博客搭建完之后，其实可以用xxxx.github.io来访问，xxxx为你的github用户名。当然很多小伙伴希望用自己的域名来访问博客，这个时候就需要去注册一个自己的域名了，我是通过 阿里云的万网 注册的,类型A的记录值是你github仓库的ip地址，ip地址可以利用终端ping一下的你仓库域名(xxxx.github.io)获取,类型CNAME则是你github仓库的域名即 xxxx.github.io,设置完域名的解析和配置github仓库后，就可以如愿的通过域名访问博客了。需要注意的是，注册完域名一定要进行实名认证，这样域名才能够正常使用。
关于hexo live2d插件 博客搭好了，你可能会觉得你的博客有点单调，这个时候就可以利用live2d插件添加一个你喜欢的看板娘，看板娘的类型有很多，可以到 live2d插件作者的博客观摩 ，配置live2d插件很简单，可以根据 live2d插件github 中的md进行配置，相信这些难不倒你。 如果你和我一样用的是next主题的话，
live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 以上配置应该是添加到Hexo的**_config.yml文件，而不是主题的_config.yml**文件。(我一开始添加到主题的配置文件中毫无作用。。。) 现在，看板娘已经出现在你的博客中了，如果你想了解更多live2d插件配置的属性可以参阅 live2d-widget.js API 。如果你想制作你自己的看板娘到自己的博客，可以参阅 live2d官网 和这两篇文章
给博客添加能动的看板娘(Live2D)-关于模型的二三事 给博客添加能动的看板娘(Live2D)-将其添加到网页上吧 关于NexT主题 NexT主题是很多人的选择，其优点在于满足了大部分人对于简约的要求，同时又有许多子主题可供选择，还能结合第三方的插件进行使用，还有更多的进阶个性化设置，如SEO、评论系统、个人头像、博客分享、订阅功能、High功能、404网页设置等，可以参看：
NexT官网 NexT的github地址</content></entry><entry><title>站点示例</title><url>/flinks.html</url><categories/><tags/><content type="html">如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</content></entry></search>